package com.javarush.task.task18.task1815;

import java.util.List;
/* 
Таблица

Измени класс TableInterfaceWrapper так, чтобы он стал Wrapper-ом для TableInterface.
Метод setModel должен вывести в консоль количество элементов в новом листе перед обновлением модели.
Метод getHeaderText должен возвращать текст в верхнем регистре - используйте метод toUpperCase().

Требования:
1. Класс TableInterfaceWrapper должен реализовывать интерфейс TableInterface.
2. Класс TableInterfaceWrapper должен инициализировать в конструкторе поле типа TableInterface.
3. Метод setModel() должен вывести в консоль количество элементов в новом листе перед обновлением модели.
4. Метод getHeaderText() должен возвращать текст в верхнем регистре.
5. Метод setHeaderText() должен устанавливать текст для заголовка без изменений.
*/
public class Solution {
//1. Класс TableInterfaceWrapper должен реализовывать интерфейс TableInterface.
    public class TableInterfaceWrapper implements TableInterface {
//2. Класс TableInterfaceWrapper должен инициализировать в конструкторе поле типа TableInterface.
        TableInterface tableInterface;
        public TableInterfaceWrapper(TableInterface tableInterface) {
            this.tableInterface = tableInterface;
        }
//3. Метод setModel() должен вывести в консоль количество элементов в новом листе перед обновлением модели.
        @Override
        public void setModel(List rows) {
            System.out.println(rows.size());
            tableInterface.setModel(rows);
        }
//4. Метод getHeaderText() должен возвращать текст в верхнем регистре.
        @Override
        public String getHeaderText() {
        //    return null;
            return tableInterface.getHeaderText().toUpperCase();
        }
//5. Метод setHeaderText() должен устанавливать текст для заголовка без изменений.
        @Override
        public void setHeaderText(String newHeaderText) {
            tableInterface.setHeaderText(newHeaderText);
        }
    }
    public interface TableInterface {
        void setModel(List rows);

        String getHeaderText();

        void setHeaderText(String newHeaderText);
    }
    public static void main(String[] args) {
    }
}
//Долго притормаживал. Для таких же как я.
//
//В конструктор обертки передается любой объект который реализует тот интерфейс, который мы хотим обернуть. То есть, в нашем случае это TableInterface. В задаче его методы не реализованы - меня это несколько сбивало с толку. Но это задача, а не реальный, имеющий практический смысл код. И еще раз. Если у нас есть 10 экземпляров/объектов различных классов, но каждый из которых реализует интерфейс, который мы хотим обернуть, то совершенно все равно какой объект мы будем передавать в класс-обертку. У них у всех реализованы методы которые мы собираемся использовать - методы интересующего интерфейса.
//
//В практической задаче мы будем делать обертку на полностью реализованные методы интерфейса - потому как нельзя сделать обертку на ничто. То есть, передали объект в котором реализован заворачиваемый интерфейс, а значит у этого объекта/экземпляра есть реализованные методы этого интерфейса, и мы в наших переопределенных методах просто передаем в соответствующие методы этого объекта (методы одноименные с переименованными) входные параметры.
//
//Мы можем передать некий громоздкий непонятный объект в котором 535 функций. Это не важно. Главное, что бы в нем был реализован интерфейс TableInterface (в нашем случае). Это будет означать, что среди этих 535 функций обязательно есть реализация для наших 3 функций интерфейса TableInterface. Остальные 532 функции для нас мусор. Так как мы ленимся создавать наши 3 метода, то нас интересуют только их реализации. Мы хлопаем в ладоши, злорадно хихикаем и переопределяем эти три функции в нашем классе-обертке. А внутри каждой функции ни чего не делая (или делая по необходимости) просто ссылаемся на наш объект (535 функций) и через точку вызываем его одноименный метод в который передаем входные параметры (если таковые есть).
//
//Простите за обилие слов. Растрогался после решения задачи.