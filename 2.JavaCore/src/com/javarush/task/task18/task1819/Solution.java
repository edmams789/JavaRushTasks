package com.javarush.task.task18.task1819;

/* 
Объединение файлов

Считать с консоли 2 имени файла.
В начало первого файла записать содержимое второго файла так, чтобы получилось объединение файлов.
Закрыть потоки.

Требования:
1. Программа должна два раза считать имена файлов с консоли.
2. Не используй в программе статические переменные.
3. Для первого файла создай поток для чтения и считай его содержимое.
4. Затем, для первого файла создай поток для записи(поток для записи должен быть один).
Для второго - для чтения.
5. Содержимое первого и второго файла нужно объединить в первом файле.
6. Сначала должно идти содержимое второго файла, затем содержимое первого.
7. Созданные для файлов потоки должны быть закрыты.
*/

import java.io.*;

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        String file1 = reader.readLine();
        String file2 = reader.readLine();

        FileInputStream fileForReading = new FileInputStream(file1);
     //   byte[] buffer = new byte[file1.available() + fileForReading.available()];

        FileOutputStream fos1 = new FileOutputStream(file1, true);
      //  while (fis1.available() > 0){
      //      int a = fis1.read();
      //      fis1.close();

      //      fos1.write(a);
      //      fos1.close();
        }



    //    FileInputStream fis2 = new FileInputStream(reader.readLine());
     //   while (fis2.available() > 0){
     //       int a = fis2.read();
     //       fis2.close();

      //      fos1.write(a);
     //       fos1.close();
        }





//если ещё не ответили.. естестевнно потому что с одним файлом одновременно не могут работать стримы и чтения и записи.
// Работает последний занявший файл.
//ЧтениСтрим(Файл1)
//ЗаписьСтрим(Файл1)
//чтение() - не сработает, потому что уже другой стрим занял файл.
//
//правильно делать
//ЧтениеСтрим(Файл1)
//чтение
//ЧтениеСтрим(файл1).закрыть
//ЗаписьСтрим(Файл1)
//запись
//ЗаписьСтрим(Файл1).закрыть
//ЗаписьСтрим(Файл1+дозапись)
//дозапись
//ЗаписьСтрим(Файл1+дозапись).закрыть
//
//не держите стримы висячими в перемешку и отбирающими друг у друга ресурсы.
// Использвоали, больше не надо? закрыть сразу. Меньше путаницы будет.

//Придерживался логики "записать все в буфер, потом записать готовый  буфер в файл"
//1. Создаем буфер равный сумме размеров двух файлов
//2. Читаем в буфер первый файл с позиции "длина второго файла", размер - длина первого файла
//3. Читаем в начало буфера с позиции 0, размер - длина второго файла
//4. Пишем итоговый буфер в первый файл
//В коде это выглядит так
//byte[] buffer = new byte[file1.available() + fileForReading.available()];
//
//        while (file1.available() > 0) {
//           file1.read(buffer, fileForReading.available(), file1.available());
//        }
//
//        while (fileForReading.available() > 0) {
//            fileForReading.read(buffer, 0, fileForReading.available());
//        }
//
//        FileOutputStream fileForWriting = new FileOutputStream(resultFile);
//        fileForWriting.write(buffer, 0, buffer.length);

//Очень важна последовательность действий !
// Если открыты потоки записи в файл и одновременно поток чтения из этого же файла,
// то в него можно только писать, но не читать, метод read() запускается, но безрезультатно !
//- Открываем потоки для чтения.
//- Сливаем оба файла в массивы.
//- Закрываем оба потока.
//- Затем только открываем поток для записи в файл.
//
//
//а точнее это предложение:
//
//Если открыты потоки записи в файл и одновременно поток чтения из этого же файла,
// то в него можно только писать, но не читать, метод read() запускается, но безрезультатно !